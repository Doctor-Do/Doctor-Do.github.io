{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tages","text":"","link":"/tages/index.html"},{"title":"test","text":"","link":"/test/index.html"}],"posts":[{"title":"4.25LeetCode","text":"总结： 昨天晚上被蚊子咬到睡不着觉，好不容易进入梦乡，恍惚间又听到噗通一声，我当时就料想到是手机掉到床柜后面去了，于是早上七点多钟又爬起来翻箱倒柜找手机关闹钟。所以意料当中地今天上午下午摸鱼只做了三条题目，都是比较ez的，晚上划水搭建了下博客。 701. Insert into a Binary Search TreeGiven the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them. For example, Given the tree: 4 / \\ 2 7 / \\ 1 3 And the value to insert: 5 You can return this binary search tree: 4 / \\ 2 7 / \\ / 1 3 5 This tree is also valid: 5 / \\ 2 7 / \\ 1 3 \\ 4 解答:方案1 递归解决123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* insertIntoBST(TreeNode* root, int val) { if(!root) return new TreeNode(val); if(val &gt; root-&gt;val){ if(root-&gt;right==nullptr) root-&gt;right=new TreeNode(val); else insertIntoBST(root-&gt;right,val); } else if(val &lt; root-&gt;val){ if(root-&gt;left==nullptr) root-&gt;left=new TreeNode(val); else insertIntoBST(root-&gt;left,val); } return root; }}; 方案2 迭代求解，用时明显短于递归1234567891011121314151617class Solution {public: TreeNode* insertIntoBST(TreeNode* root, int val) { if(!root) return new TreeNode(val); TreeNode *p=root; while(1){ if(val&lt;p-&gt;val&amp;&amp;p-&gt;left) p=p-&gt;left; else if(val&gt;p-&gt;val&amp;&amp;p-&gt;right) p=p-&gt;right; else break; } if(p-&gt;val &lt;val) p-&gt;right=new TreeNode(val); else p-&gt;left=new TreeNode(val); return root; }}; 原题中特地强调，可以改变树的结构，但是相对来说比较复杂，翻了翻评论区并没有这么写的解答，我思考了下，感觉与平衡二叉树的删除类似，在找到其应该插入位置后根据是否存在左右子树分类谈论。二叉树实在是太复杂啦！ 235. Lowest Common Ancestor of a Binary Search Tree 二叉搜索树的最近公共祖先Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5] Example 1: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8Output: 6Explanation: The LCA of nodes 2 and 8 is 6. Example 2: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4Output: 2Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes’ values will be unique.p and q are different and both values will exist in the BST. 解法： 递归实在是太好写啦，主要注意其二叉搜索树的特性。123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(!root) return nullptr; if(p-&gt;val&lt;root-&gt;val &amp;&amp; q-&gt;val&gt;root-&gt;val) return root; if(p-&gt;val&gt;root-&gt;val &amp;&amp; q-&gt;val&lt;root-&gt;val) return root; if(p==root||q==root) return root; if(p-&gt;val&lt;root-&gt;val &amp;&amp; q-&gt;val&lt;root-&gt;val) return lowestCommonAncestor(root-&gt;left,p,q); if(p-&gt;val&gt;root-&gt;val &amp;&amp; q-&gt;val&gt;root-&gt;val) return lowestCommonAncestor(root-&gt;right,p,q); return root; }}; 589. N-ary Tree Preorder Traversal N叉树的前序遍历 一开始写了个递归版本，发现速度很慢，想写迭代版本，但是感觉和二叉树又不太一样 参考了下评论区大神的思路 豁然开朗 随便写写写下来，发现时间还是特别高！ 非常生气地拿了80ms的源码来跑，结果虽然比我的好，还是很高。 就有点懵逼了。 感觉这个迭代写法还是可以学习一下，和之前常写的二叉树的前序遍历迭代版本不太相同。（对栈的使用）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/*// Definition for a Node.class Node {public: int val; vector&lt;Node*&gt; children; Node() {} Node(int _val, vector&lt;Node*&gt; _children) { val = _val; children = _children; }};*/// class Solution {// public:// vector&lt;int&gt; preorder(Node* root) {// vector&lt;int&gt; res;// help(root,res);// return res;// }// void help(Node* p,vector&lt;int&gt;&amp; res){// if(!p) return;// res.push_back(p-&gt;val);// for(auto it:p-&gt;children)// help(it,res);// }// };// class Solution {// public:// vector&lt;int&gt; preorder(Node* root) {// stack&lt;Node*&gt; stk;// vector&lt;int&gt; res;// if(!root) return res;// Node* p=root;// stk.push(p);// while(!stk.empty()){// p=stk.top();stk.pop();// res.push_back(p-&gt;val);// if(p-&gt;children.empty())// continue;// else{// for(auto it=p-&gt;children.rbegin();it!=p-&gt;children.rend();it++)// stk.push(*it);// }// }// return res; // }// };class Solution {public: vector&lt;int&gt; preorder(Node* root) { vector&lt;int&gt; res; if(root == nullptr) return res; stack&lt;Node*&gt; st; st.push(root); while(!st.empty()) { Node* t = st.top(); st.pop(); res.push_back(t-&gt;val); for(auto r = t-&gt;children.rbegin(); r != t-&gt;children.rend(); r++) { st.push(*r); } } return res; }};","link":"/2019/04/25/190425/"},{"title":"4.28LeetCode","text":"38. Count and Say 报数emmmmm.题目比较难读懂，读懂很简单啦。 1234567891011121314151617181920212223242526272829class Solution {public: string countAndSay(int n) { string res=\"1\"; for(int i=1;i&lt;n;i++) res=next(res); return res; } string next(string n) { int i=0; string res; while(i&lt;n.length()){ char temp=n[i]; int num=1; while(1){ if(i+1!=n.length()&amp;&amp;n[i+1]==n[i]) { num++; i++; } else break; } res+=to_string(num); res+=temp; i++; } return res; }}; 237. Delete Node in a Linked List 删除链表中的节点感觉还是思路被桎梏了哈哈，说到删除节点第一时间想的永远是让被删除的前一个结点next指向被删除的next，为什么不换个思路去重新生成从被删除开始之后的整个链表呢 1234567891011121314class Solution {public: void deleteNode(ListNode* node) { ListNode* p=node; while(p-&gt;next){ p-&gt;val=p-&gt;next-&gt;val; p=p-&gt;next; } while(node-&gt;next!=p) node=node-&gt;next; node-&gt;next=nullptr; return; }}; 88. Merge Sorted Array 合并两个有序数组 1234567891011121314151617181920212223242526272829303132333435class Solution {public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int i=0,j=0; vector&lt;int&gt; temp; while(i&lt;m&amp;&amp;j&lt;n){ if(nums1[i]&lt;=nums2[j]) { temp.push_back(nums1[i]); i++; }else{ temp.push_back(nums2[j]); j++; } } if(i!=m){ while(i!=m){ temp.push_back(nums1[i]); i++; } } if(j!=n){ while(j!=n){ temp.push_back(nums2[j]); j++; } } i=0; for(int it:temp){ nums1[i]=it; i++; } return; }}; 70. Climbing Stairs 爬楼梯斐波那契数列。。 123456789101112class Solution {public: int climbStairs(int n) { if(n==1) return 1; vector&lt;int&gt; dp; dp.resize(n); dp[0]=1;dp[1]=2; for(int i=2;i&lt;n;i++) dp[i]=dp[i-1]+dp[i-2]; return dp[n-1]; }}; 53. Maximum Subarray 最大子序和这题实在是太难了。。。想了一上午都没想明白，说到底还是自己太菜了。。。到现在也只是勉强能理解标准答案。评论区大佬解答：这道题难度不该是easy 这道题的一开始我想到的是暴力的滑窗去做，复杂度O(n^2)，显然达不到题目中要求的复杂度 这道题根据题目关键词，“最大”“连续”，可以判断是一道动态规划，附上这道题目的wiki链接https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E5%88%97%E9%97%AE%E9%A2%98 方法如下：1.定义一个函数f(n)，以第n个数为结束点的子数列的最大和，存在一个递推关系f(n) = max(f(n-1) + A[n], A[n]);2.将这些最大和保存下来后，取最大的那个就是，最大子数组和。因为最大连续子数组 等价于 最大的以n个数为结束点的子数列和 12345678910111213class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int tempmax,res; res=nums[0]; tempmax=0; for(int i=0;i&lt;nums.size();i++){ tempmax=max(tempmax+nums[i],nums[i]); res=max(res,tempmax); } return res; }};","link":"/2019/04/28/190428/"},{"title":"4.27LeetCode","text":"26. Remove Duplicates from Sorted Array 从排序数组中删除重复项双指针法解决。当数值不同且不指向同一个时替换。写的有点丑陋，可以利用nums[i]的值去替代temp 12345678910111213141516171819202122class Solution {public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { if(nums.empty()) return 0; int i=j=0; int temp=nums[i]; int res=1; while(j&lt;nums.size()){ if(temp&lt;nums[j]){ res++; if(i!=j) { i++; nums[i]=nums[j]; } temp=nums[j]; } j++; } return res; }}; 121. Best Time to Buy and Sell Stock 买卖股票的最佳时机动态规划 前i天的最大收益 = max{前i-1天的最大收益，第i天的价格-前i-1天中的最小价格} 12345678910111213141516171819class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { if(prices.empty()) return 0; vector&lt;int&gt; dp; dp.resize(prices.size()); dp[0]=0; int minp=prices[0]; for(int i=1;i&lt;prices.size();i++){ if(prices[i]&lt;=prices[i-1]) dp[i]=dp[i-1]; else if(prices[i]-minp&gt;dp[i-1]) dp[i]=prices[i]-minp; else dp[i]=dp[i-1]; minp=min(minp,prices[i]); } return dp[prices.size()-1]; }}; 122. Best Time to Buy and Sell Stock II 买卖股票的最佳时机 II贪心没啥思路，偷看了评论区的答案：[7, 1, 5, 6] 第二天买入，第四天卖出，收益最大（6-1），所以一般人可能会想，怎么判断不是第三天就卖出了呢? 这里就把问题复杂化了，根据题目的意思，当天卖出以后，当天还可以买入，所以其实可以第三天卖出，第三天买入，第四天又卖出（（5-1）+ （6-5） === 6 - 1）。所以算法可以直接简化为只要今天比昨天大，就卖出。 1234567891011121314151617class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { if(prices.empty()) return 0; int res=0; int pricenow=prices[0]; //默认持有价格 for(int i=1;i&lt;prices.size();i++){ if(prices[i]&lt;=pricenow) //当天价格比你持有的低,直接放弃之前的 pricenow=prices[i]; else{ res+=prices[i]-pricenow; pricenow=prices[i]; } } return res; }}; 48. Rotate Image 旋转图像虽然是道medium题，但是感觉其实也没很难。。想了很久才明白旋转规则。（四个结点旋转） 1234567891011121314151617class Solution {public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { if(matrix.empty()) return; int n=matrix.size(); for(int i=0;i&lt;n/2;i++){ for(int j=i;j&lt;n-i-1;j++){ int temp=matrix[i][j]; matrix[i][j]=matrix[n-1-j][i]; matrix[n-1-j][i]=matrix[n-1-i][n-1-j]; matrix[n-1-i][n-1-j]=matrix[j][n-1-i]; matrix[j][n-1-i]=temp; } } return; }}; 242. Valid Anagram 有效的字母异位词建立字母表 再比较。 也可以用map去做。 1234567891011121314class Solution {public: bool isAnagram(string s, string t) { int a[26]={0}; int b[26]={0}; for(int i=0;i&lt;s.length();i++) a[s[i]-'a']++; for(int i=0;i&lt;t.length();i++) b[t[i]-'a']++; for(int i=0;i&lt;26;i++) if(a[i]!=b[i]) return false; return true; }}; 125. Valid Palindrome 验证回文串双指针法，感觉贴题目好有成就感。。题目不难，比较繁琐的是大小写的转换以及干扰字符去除的写法。 1234567891011121314151617181920212223242526class Solution {public: bool isPalindrome(string s) { if(s.empty()) return true; int i=0,j=s.length()-1; while(i&lt;j){ while(1){ if((s[i]&gt;='0'&amp;&amp;s[i]&lt;='9')||(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z')||(s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z')||i==j) break; i++; } while(1){ if((s[j]&gt;='0'&amp;&amp;s[j]&lt;='9')||(s[j]&gt;='a'&amp;&amp;s[j]&lt;='z')||(s[j]&gt;='A'&amp;&amp;s[j]&lt;='Z')||i==j) break; j--; } if(i==j) break; char p=s[i],q=s[j]; if(p&gt;='A'&amp;&amp;p&lt;='Z') p+=32; if(q&gt;='A'&amp;&amp;q&lt;='Z') q+=32; if(p!=q) return false; i++; j--; } return true; }}; 8. String to Integer (atoi) 字符串转换整数 (atoi)还是属于比较简单的medium主要考察一个细心把。。 1234567891011121314151617181920212223242526class Solution {public: int myAtoi(string str) { long long res=0; if(str.empty()) return 0; int i; for(i=0;i&lt;str.length();i++) if(str[i]!=' ') break; if(i==str.length()||(str[i]&lt;'0'&amp;&amp;str[i]!='-'&amp;&amp;str[i]!='+')||str[i]&gt;'9') return 0; char temp=str[i]; if(str[i]=='-'||str[i]=='+') i++; while(i&lt;str.length()){ if(str[i]&gt;='0'&amp;&amp;str[i]&lt;='9') { if(res&gt;pow(2,31)-1) return temp=='-'?INT_MIN:INT_MAX; res=res*10+(int)(str[i]-'0'); i++; } else break; } if(temp=='-') res=res*(-1); if(res&gt;pow(2,31)-1) return INT_MAX; if(res&lt;pow(2,31)*(-1)) return INT_MIN; return res; }}; 28. Implement strStr() 实现strStr() 1234567891011121314151617181920212223// 我枯了，明明是道ez题，居然随便写写过不了。。。还要剪枝。。class Solution {public: int strStr(string haystack, string needle) { if(needle.empty()) return 0; int n1=haystack.length(),n2=needle.length(); if(n2&gt;n1) return -1; int i=0; while(i+n2&lt;=haystack.length()){ int t=i; int j=0; for( j=0;j&lt;needle.length();j++) { if(haystack[t]!=needle[j]) break; t++; } if(j==needle.length()) return i; i++; } return -1; }};","link":"/2019/04/27/190427/"},{"title":"4.30LeetCode","text":"五一快乐！！！ 461. Hamming Distance 汉明距离 1234567891011class Solution { public int hammingDistance(int x, int y) { int z=x^y; int res=0; while(z!=0){ res++; z=z&amp;(z-1); } return res; }} 190. Reverse Bits 颠倒二进制位 12345678910public class Solution { public int reverseBits(int n) { int rs = 0; for (int i = 0; i &lt; 32; i++) { rs &lt;&lt;= 1; rs -= n &lt;&lt; 31 - i &gt;&gt; 31; } return rs; }} 268. Missing Number 缺失数字 1234567891011class Solution { public int missingNumber(int[] nums) { int res=0; for(int i=0;i&lt;nums.length;i++){ res^=nums[i]; res^=i; } res^=nums.length; return res; }}","link":"/2019/04/30/190430/"},{"title":"190504","text":"46. Permutations 46.全排列 1234567891011121314151617181920212223242526272829class Solution { public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) { List&lt;List&lt;Integer&gt;&gt; res =new ArrayList&lt;&gt;(); List&lt;Integer&gt; t= new ArrayList&lt;&gt;(); boolean[] visited=new boolean[nums.length]; helpBFS(res,t,nums,visited); return res; } public void helpBFS(List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; t,int[] nums,boolean[] visited){ if(t.size()==nums.length){ List&lt;Integer&gt; temp=new ArrayList&lt;&gt;(); for(Integer i:t) temp.add(i); res.add(temp); return; } for(int i=0;i&lt;nums.length;i++){ if(visited[i]) continue; else{ t.add(nums[i]); visited[i]=!visited[i]; helpBFS(res,t,nums,visited); t.remove((Integer)nums[i]); visited[i]=!visited[i]; } } }} 78. Subsets 子集和上一题类似 12345678910111213141516171819202122class Solution { public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;(); List&lt;Integer&gt; t=new ArrayList&lt;&gt;(); boolean[] visited=new boolean[nums.length]; help(res,t,visited,nums,0); return res; } public void help(List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; t,boolean[] visited,int[] nums,int start){ res.add(new ArrayList(t)); for(int i=start;i&lt;nums.length;i++){ if(visited[i]) continue; else{ t.add(nums[i]); visited[i]=true; help(res,t,visited,nums,i+1); //关键点，从i+1往回再考虑 visited[i]=false; t.remove((Integer)nums[i]); } } }} 79. Word Search 单词搜索DFS+回溯。。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { public boolean exist(char[][] board, String word) { if(word.length()&gt;board.length*board[0].length) return false; for(int i=0;i&lt;board.length;i++) for(int j=0;j&lt;board[0].length;j++){ if(board[i][j]==word.charAt(0)) { boolean[][] visited=new boolean[board.length][board[0].length]; visited[i][j]=true; boolean temp=help(i,j,board,word,0,visited); if(temp) return true; } } return false; } public boolean help(int i,int j,char[][] board,String word,int num,boolean[][] visited){ if(i&lt;0||i&gt;board.length||j&lt;0||j&gt;board[0].length||word.charAt(num)!=board[i][j]) return false; if(num+1==word.length()) return true; boolean t1,t2,t3,t4; t1=t2=t3=t4=false; if(i-1&gt;=0&amp;&amp; board[i-1][j]==word.charAt(num+1)&amp;&amp;visited[i-1][j]==false) { visited[i-1][j]=true; if(t1=help(i-1,j,board,word,num+1,visited)) return true; visited[i-1][j]=false; } if(j+1&lt;board[0].length&amp;&amp;board[i][j+1]==word.charAt(num+1)&amp;&amp;visited[i][j+1]==false) { visited[i][j+1]=true; if(t2=help(i,j+1,board,word,num+1,visited)) return true; visited[i][j+1]=false; } if(i+1&lt;board.length&amp;&amp;board[i+1][j]==word.charAt(num+1)&amp;&amp;visited[i+1][j]==false) { visited[i+1][j]=true; if(t3=help(i+1,j,board,word,num+1,visited)) return true; visited[i+1][j]=false; } if(j-1&gt;=0&amp;&amp; board[i][j-1]==word.charAt(num+1)&amp;&amp;visited[i][j-1]==false){ visited[i][j-1]=true; if(t4=help(i,j-1,board,word,num+1,visited)) return true; visited[i][j-1]=false; } return false; }} 75. Sort Colors 75.颜色分类三路快排 1234567891011121314151617181920class Solution { public void sortColors(int[] nums) { int i=-1,j=nums.length; int k=0; while(k&lt;j){ if(nums[k]==0){ i++; nums[k]=nums[i]; nums[i]=0; k++; } else if(nums[k]==2){ j--; nums[k]=nums[j]; nums[j]=2; } else k++; } }}","link":"/2019/05/04/190504/"},{"title":"5.7LeetCode","text":"昨天太累了，就没更新。。今天一起更下。昨天主要做的基本都是比较简单的dp题目。 55. Jump Game 55.跳跃游戏 因为是dp专题，所以肯定有dp解法：其实感觉也不算严谨的dp吧。。canGo[n]表示n可否到达 1234567891011121314151617class Solution { public boolean canJump(int[] nums) { boolean[] canGo=new boolean[nums.length]; canGo[0]=true; for(int i=0;i&lt;nums.length;i++){ if(canGo[i]){ int j=i+1; while(j&lt;nums.length&amp;&amp;j&lt;=i+nums[i]){ canGo[j]=true; j++; } } if(canGo[nums.length-1]) return true; } return canGo[nums.length-1]; }} 还有种复杂度是O(n)的解法，求出从0出发可以到达的最远点。 12345678910class Solution { public boolean canJump(int[] nums) { int maxlength=nums[0]; for(int i=0;i&lt;=maxlength;i++){ if(maxlength&gt;=nums.length-1) return true; if(nums[i]+i&gt;maxlength) maxlength=nums[i]+i; } return false; }} 62. Unique Paths 62.不同路径 dp解法非常简单。。 12345678910111213class Solution { public int uniquePaths(int m, int n) { int[][] dp=new int[m][n]; for(int i=0;i&lt;n;i++) dp[0][i]=1; for(int i=0;i&lt;m;i++) dp[i][0]=1; for(int i=1;i&lt;m;i++) for(int j=1;j&lt;n;j++) dp[i][j]=dp[i-1][j]+dp[i][j-1]; return dp[m-1][n-1]; }} 另外一种解法就是求C(m-1,m+n-2)。 322. Coin Change 零钱兑换 123456789101112131415161718class Solution { public int coinChange(int[] coins, int amount) { if(amount==0) return 0; int[] dp=new int[amount+1]; for(int i=0;i&lt;amount+1;i++) dp[i]=Integer.MAX_VALUE; for(int i:coins) if(i&lt;=amount) dp[i]=1; for(int i=1;i&lt;amount+1;i++) for(int j:coins){ if(i-j&gt;0&amp;&amp;dp[i-j]!=Integer.MAX_VALUE&amp;&amp;dp[i-j]+1&lt;dp[i]) dp[i]=dp[i-j]+1; } //return dp[amount]; return dp[amount]==Integer.MAX_VALUE? -1:dp[amount]; }} 300. Longest Increasing Subsequence1234567891011121314151617181920class Solution { public int lengthOfLIS(int[] nums) { int[] dp=new int[nums.length]; for(int i=0;i&lt;nums.length;i++) dp[i]=1; for(int i=1;i&lt;nums.length;i++) for(int j=i-1;j&gt;=0;j--) if(nums[i]&gt;nums[j]&amp;&amp;dp[j]+1&gt;dp[i]) dp[i]=dp[j]+1; int max=0; for(int i:dp){ //System.out.println(i); if(i&gt;max) max=i; } return max; }} 297. Serialize and Deserialize Binary Tree 二叉树的序列化与反序列化一道不是非常hard的hard题，深切感受到了StringBuffer的快速。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */public class Codec { // Encodes a tree to a single string. public String serialize(TreeNode root) { Queue&lt;TreeNode&gt; queue=new LinkedList&lt;&gt;(); StringBuffer res=new StringBuffer(); if(root==null) return res.toString(); res.append(String.valueOf(root.val)); queue.offer(root.left); queue.offer(root.right); while(!queue.isEmpty()) { int size=queue.size(); for(int i=0;i&lt;size;i++){ TreeNode t=queue.poll(); if(t==null){ res.append(&quot;,null&quot;); } else{ res.append(&quot;,&quot;); res.append(String.valueOf(t.val)); queue.offer(t.left); queue.offer(t.right); } } } //System.out.println(res); return res.toString(); } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { if(data.length()==0) return null; String[] s=data.split(&quot;,&quot;); int n=s.length; for(int i=s.length-1;i&gt;=0;i--) if(s[i].equals(&quot;null&quot;)) n--; else break; // for(int i=0;i&lt;n;i++) // System.out.println(s[i]); TreeNode[] node=new TreeNode[n]; int j=1; for(int i=0;i&lt;n;i++) if(!s[i].equals(&quot;null&quot;)) node[i]=new TreeNode(0); else node[i]=null; for(int i=0;i&lt;n;i++) if(!s[i].equals(&quot;null&quot;)){ node[i].val=Integer.parseInt(s[i]); if(j&lt;n&amp;&amp;!s[j].equals(&quot;null&quot;)) node[i].left=node[j]; j++; if(j&lt;n&amp;&amp;!s[j].equals(&quot;null&quot;)) node[i].right=node[j]; j++; } else node[i]=null; return node[0]; }} 172. Factorial Trailing Zeroes 阶乘后的零数学题。找规律。还以优化下，从两次循环减少到1次循环。 12345678910111213class Solution { public int trailingZeroes(int n) { int max=0; int t=n; while(t!=0){ t=t/5; max++; } int res=0; for(int i=1;i&lt;max;i++) res+=n/Math.pow(5,i); return res; }}","link":"/2019/05/07/190507/"},{"title":"5.9 LeetCode","text":"166. Fraction to Recurring Decimal 分数到小数给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。如果小数部分为循环小数，则将循环的部分括在括号内。 1234567891011121314151617181920212223242526272829303132333435363738class Solution { public String fractionToDecimal(int numerator, int denominator) { long n=Math.abs((long)numerator),d=Math.abs((long)denominator); StringBuilder sb=new StringBuilder(); if((long)numerator * (long)denominator &lt; 0) sb.append(&quot;-&quot;); sb.append(String.valueOf(n/d)); n%=d; if(n==0) return sb.toString(); sb.append(&quot;.&quot;); int t=2; while(t&lt;n){ if((n/t)*t==n &amp;&amp;(d/t)*t==d) { n/=t;d/=t; } else t++; } //System.out.println(n+&quot; &quot;+d); long index=sb.length(); HashMap&lt;Long,Long&gt; m=new HashMap&lt;&gt;(); while(n!=0){ if(m.containsKey(n)){ sb.insert(Integer.parseInt(m.get(n).toString()),&quot;(&quot;); sb.append(&quot;)&quot;); break; } m.put(n,index); n*=10; sb.append(n/d); n=n%d; index++; } return sb.toString(); }} 371. Sum of Two Integers 371.两整数之和不使用运算符 + 和 - ​​​​​​​，计算两整数 ​​​​​​​a 、b ​​​​​​​之和。 12345class Solution { public int getSum(int a, int b) { return b == 0 ? a : getSum(a^b,(a&amp;b)&lt;&lt;1); }}","link":"/2019/05/09/190509/"},{"title":"5.5LeetCode","text":"215. Kth Largest Element in an Array 数组中的第K个最大元素感觉是非常经典的一道题目，一开始自己尝试了下手写快排。。一堆bug，又百度学了半天快排算法。。然后试了下评论区大佬的最小堆，这快的也太多了把！完全不是一个数量级的。感觉手写一个堆结构也是很基本的能力，任重而道远。 123456789101112131415161718192021222324252627class Solution { public int findKthLargest(int[] nums, int k) { int left=0,right=nums.length-1; while (true) { int pos = help(left,right,nums); if (pos == k - 1) return nums[pos]; else if (pos &gt; k - 1) right = pos - 1; else left = pos + 1; } } public int help(int left,int right, int[] nums){ int pivot = nums[left], l = left + 1, r = right; while (l &lt;= r) { if (nums[l] &lt; pivot &amp;&amp; nums[r] &gt; pivot) { int temp=nums[l]; nums[l]=nums[r]; nums[r]=temp; l++; r--; } if ( nums[l] &gt;= pivot) ++l; if (nums[r] &lt;= pivot) --r; } int temp=nums[r]; nums[r]=nums[left]; nums[left]=temp; return r; }} 解法2️：最小堆1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution { //堆排序的过程就是首先构建大根堆，然后对顶元素（及最大元素）与最后个元素替换位置，heapsize减一，重新调整堆变成大根堆。 //重复上面操作直到heapsize等于一的时候。排序完成。 public int findKthLargest(int[] nums, int k) { // 建一个大小为k+1(第一个结点不使用)的数组 int[] heap = new int[k+1]; for(int i = 0; i &lt; k; i++){ heap[i+1] = nums[i]; } // 堆化。建立一个大小为k的小顶堆 // 从最后一个非叶子结点k/2自上往下开始进行堆化，该结点堆化完后就轮到前一个非叶子结点再自上往下进行堆化 for(int i = k/2; i &gt; 0; i--){ heapify(heap,k+1,i); } // 继续遍历数组中剩余的数字，并与堆顶元素进行比较， // 若大于堆顶元素，则替换掉堆顶元素，并自顶向下堆化 for(int i = k; i &lt; nums.length; i++){ if(nums[i] &gt; heap[1]){ heap[1] = nums[i]; heapify(heap,k+1,1); } } return heap[1]; } // 自顶向下堆化。一般在删除堆顶结点后，把最后一个结点放到堆顶的时候使用。 // 即这时堆中已经是部分堆化 private void heapify(int[] heap,int len,int index){ while(true){ // 找出当前结点和两个直接子结点的最小值 int minPos = index; if(2*index &lt; len &amp;&amp; heap[2*index] &lt; heap[minPos]){ minPos = 2*index; } if(2*index+1 &lt; len &amp;&amp; heap[2*index+1] &lt; heap[minPos]){ minPos = 2*index + 1; } // 若当前结点是最小的，说明下面的是堆化好的了，直接退出循环 if(minPos == index){ break; } // 当前结点与最小值进行交换 swap(heap,index,minPos); // 当前结点更改为最小直接子结点，继续往下堆化 index = minPos; } } private void swap(int[] nums,int i,int j){ int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; }} 56. Merge Intervals 56.合并区间看评论区，基本上都是先按照区间头排序，然后再处理。自己写了个不用sort的算法，用map去替代。有点开心。 123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { vector&lt;vector&lt;int&gt;&gt; res; map&lt;int,int&gt; hashmap; for(int i=0;i&lt;intervals.size();i++){ auto it=hashmap.find(intervals[i][0]); //处理该区间起点 if(it==hashmap.end()) //先前未访问过该结点 hashmap[intervals[i][0]]=1; else hashmap[intervals[i][0]]++; it=hashmap.find(intervals[i][1]); //处理区间终点 if(it==hashmap.end()) //先前未访问过 hashmap[intervals[i][1]]=-1; else hashmap[intervals[i][1]]--; } for(auto it=hashmap.begin();it!=hashmap.end();it++){ vector&lt;int&gt; temp; temp.push_back(it-&gt;first); int cnt=0; while(1) { cnt+=it-&gt;second; if(cnt&lt;=0) break; it++; } temp.push_back(it-&gt;first); res.push_back(temp); } return res; }}; 240. Search a 2D Matrix II 搜索二维矩阵 II也就错了这么十几次。。。自闭了。 在分治到2*2范围时我就有点不知道该如何处理了。越写头越晕，无限改BUG。不过最后效率还是相当不错的。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution { public boolean searchMatrix(int[][] matrix, int target) { if(matrix.length==0||matrix[0].length==0) return false; int m=matrix.length; int n=matrix[0].length; return help(matrix,0,n-1,0,m-1,target); } public boolean help(int[][] matrix,int left,int right,int top,int button,int target){ //System.out.println(left+&quot;+&quot;+right+&quot;+&quot;+top+&quot;+&quot;+button); if(left&lt;0||right&gt;=matrix[0].length||top&lt;0||button&gt;=matrix.length||left&gt;right||top&gt;button) return false; if(left==right&amp;&amp;top==button) return (matrix[top][right]==target); if(right-left==1&amp;&amp;button-top==1) return matrix[top][left]==target||matrix[top][right]==target||matrix[button][left]==target||matrix[button][right]==target; if(right-left==1&amp;&amp;button==top) return matrix[top][left]==target||matrix[top][right]==target; if(button-top==1&amp;&amp;right==left) return matrix[button][left]==target||matrix[top][left]==target; int midi=(top+button)/2; int midj=(left+right)/2; //System.out.println(midi+&quot;+&quot;+midj); if(matrix[midi][midj]==target) return true; else if(matrix[midi][midj]&gt;target){ boolean t=help(matrix,left,midj,top,midi,target); if(t) return true; if(matrix[midi][left]&lt;=target) t=help(matrix,left,midj-1,midi+1,button,target); if(t) return true; if(matrix[top][midj]&lt;=target) t=help(matrix,midj+1,right,top,midi-1,target); if(t) return true; } else if(matrix[midi][midj]&lt;target){ boolean t=help(matrix,midj,right,midi,button,target); if(t) return true; if(matrix[button][midj]&gt;=target) t=help(matrix,left,midj-1,midi+1,button,target); if(t) return true; if(matrix[midi][right]&gt;=target) t=help(matrix,midj+1,right,top,midi-1,target); if(t) return true; } return false; }} 感觉时间真的挺紧的，今天上午有点事情就没学习，下午和晚上加起来也就只能刷个三题，书也看不了多少啦。","link":"/2019/05/05/190505/"},{"title":"5.8 LeetCode","text":"171. Excel Sheet Column Number Excel表列序号 1234567891011class Solution { public int titleToNumber(String s) { int res=0; for(int i=0;i&lt;s.length();i++){ res*=26; res+=(s.charAt(i)-&apos;A&apos;+1); } return res; }} 50. Pow(x, n) 50.Pow(x,n)很经典的一道题。 123456789101112class Solution { public double myPow(double x, int n) { double res = 1.0; for(int i = n; i != 0; i /= 2){ if(i % 2 != 0){ res *= x; } x *= x; } return n &lt; 0 ? 1 / res : res; }} 29. Divide Two Integers 两数相除给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。返回被除数 dividend 除以除数 divisor 得到的商。 1234567891011121314151617181920212223class Solution { public int divide(int dividend, int divisor) { boolean flag=(dividend&gt;=0&amp;&amp;divisor&gt;0)||(dividend&lt;=0&amp;&amp;divisor&lt;0); int res=0; long m=Math.abs((long)dividend); long n=Math.abs((long)divisor); int i=31; while(i&gt;=0&amp;&amp;res&lt;=Integer.MAX_VALUE){ if((m&gt;&gt;i)&gt;=n){ res+=1&lt;&lt;i; m-=n&lt;&lt;i; } i--; } if(res==Integer.MIN_VALUE&amp;&amp;flag) return Integer.MAX_VALUE; if(res==Integer.MIN_VALUE&amp;&amp;!flag) return Integer.MIN_VALUE; if(flag) return res; return -res; }}","link":"/2019/05/08/190508/"},{"title":"写在2020的话","text":"现在是2020年1月16日 23:15:54在咕咕咕了大半年后，终于又有闲工夫跑回来更新blog了，实在是不容易呀！不禁感慨：（我感慨啥呢 感慨生活不容易，感慨坚持写blog的大佬们是多有毅力）现在深夜躺在床上，回忆起这大半年的点点滴滴，心里总有几分说不明道不清的喟叹。自上次断更以来，发生了太多事情，有喜有悲，也可谓是本人人生中20余年未遇之大格局。不过当所有事情尘埃落定，细细想来当初觉得天塌下来般大的事情，也只是些鸡毛蒜皮的小事罢了，而人又何尝不是如此呢？这大半年颠簸流离，几经周转，也算是确认了老师，在昆山安顿了下来。有了自己的房间，却也清净了不少，有时候倒还挺想念曾经喧闹的寝室的。从十一月启程算起，其实也料想到自己的大学群居生涯已经基本告终，但也难免有些伤感。但人总是要向前看的，至于现在的生活，我也是很喜欢的，有自己的目标，实验室老师和师兄们都很和蔼可亲，有想做的事情，但愿自己能保持这份热情，努力下去！ 说起为什么要重新开始写blog，我觉得这有几点是促使我又拿起笔的。首先，其实早在前两天的时候，也就是2000的20岁生日动笔，那又是惰性趋势，没能写的下去。再者，前两天看max+上有个老哥记录自身在上海拼搏的日子，觉得烟火气十足，再加上我这人记性不太好，所以也动了写日记的念头，记录记录自己每天的趣闻趣事，忘却真是太可惜了。然后呢，最近在看paper的过程中，发现不做笔记就很容易忘，所以用有道做了一些笔记，既然笔记都做了，我干脆上传到blog上来，也方便之后归档查阅。 所以之后的blog，也还是会以学习工作为主，有兴致了可以写点随笔感想之类。其实觉得写起来还算容易，就是找图片以及搭建blog太麻烦啦！不过在做了充足的思想工作之后，我也想明白了blog这种事情，还是要靠自身的热情，不可强求，所以以后佛性更新！反正写给自己看，爱咋写咋写！♪(＾∀＾●)ﾉ 最后还是勉励下自己吧！","link":"/2020/01/16/200116/"},{"title":"200117","text":"Counter measures for Automatic Speaker Veriﬁcation Replay Spooﬁng Attack: OnDataAugmentation,FeatureRepresentation,ClassiﬁcationandFusion相比与真实语音，录制播放语音具有更高的混响。制造spoofing数据：加混响，phaser特征提取： CQCCCQCC提取流程： 传统CQCC-GMM与该模型的区别： ResNet34:（代替CQCC+GMM): ResNet 输入为224*224 从频谱中利用STFT提取的向量输出：？？？ 分类模型(需要先提取CQCC)：GMMFDNN输入：CQCC(当前帧+前后8帧）810优化函数：交叉熵输出：0/1最终得分根据帧级后验概率的mean pooling得到 BLSTM关于RNN，LSTM ：https://zhuanlan.zhihu.com/p/32085405","link":"/2020/01/17/200117/"},{"title":"Hello World","text":"这是个markdown语法示例，我懒得删了。以后还可以参考下。Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/04/23/hello-world/"},{"title":"写在开博前的话","text":"博客作为一个逐渐被时代淘汰的产物，或许已经失去了其存在的必要。与我而言，这里可以是二十年前的树洞，十年前的日记本，五年前的笔记。 步入大三下学期以来，的确感受到了对未来的迷茫与无助。开这个博客的目的，主要还是希望自己能够坚持每日更新所学知识到其上，不定期可能更新一些自己的一些思考，理念，烦心事种种。 希望自己明年这个时候，再回头看这个博客时，有所收获！祝愿各位在抵达路途的末端，都不会后悔。","link":"/2019/04/25/paper/"},{"title":"4.26LeetCode","text":"590. N-ary Tree Postorder TraversalN叉树的后序遍历解法一：递归1234567891011121314151617181920212223242526272829/*// Definition for a Node.class Node {public: int val; vector&lt;Node*&gt; children; Node() {} Node(int _val, vector&lt;Node*&gt; _children) { val = _val; children = _children; }};*/class Solution {public: vector&lt;int&gt; postorder(Node* root) { vector&lt;int&gt; res; help(root,res); return res; } void help(Node* p,vector&lt;int&gt;&amp; res){ if(!p) return ; for(auto i:p-&gt;children) help(i,res); res.push_back(p-&gt;val); }}; 解法二：迭代我们也可以使用迭代的方法来做，这里有个小trick，写法跟先序遍历十分的像，不同的就是每次把从stack中取的结点的值都加到结果res的最前面，还有就是遍历子结点数组的顺序是正常的顺序，而前序遍历是从子结点数组的后面往前面遍历，这点区别一定要注意。 1234567891011121314class Solution {public: vector&lt;int&gt; postorder(Node* root) { vector&lt;int&gt; res; help(root,res); return res; } void help(Node* p,vector&lt;int&gt;&amp; res){ if(!p) return ; for(auto i:p-&gt;children) help(i,res); res.push_back(p-&gt;val); }}; 429. N-ary Tree Level Order Traversal层次遍历，没啥好说的。1234567891011121314151617181920212223class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) { vector&lt;vector&lt;int&gt;&gt; res; if(!root) return res; deque&lt;Node*&gt; temp; temp.push_back(root); while(!temp.empty()){ int size=temp.size(); vector&lt;int&gt; t; for(int i=0;i&lt;size;i++){ auto it=temp.front(); temp.pop_front(); t.push_back(it-&gt;val); for(auto j:it-&gt;children) temp.push_back(j); } res.push_back(t); t.clear(); } return res; }}; 559. Maximum Depth of N-ary Tree N叉树的最大深度 递归非常简单。。没啥好说的12345678910111213141516class Solution {public: int maxDepth(Node* root) { int res=0; help(root,0,res); return res; } void help(Node* p,int s,int&amp; res) { if(!p) return; s++; res=s&gt;res? s:res; for(auto it:p-&gt;children) help(it,s,res); }}; 208. Implement Trie (Prefix Tree)比较简单的medium题了，就是比较繁琐。在定义前缀树的时候要先去检查是否已经存在该结点。感觉还是对map的使用不够熟练。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Node {public: bool isWord=false; unordered_map&lt;char,Node*&gt; next; Node() { isWord=false; } Node(unordered_map&lt;char,Node*&gt; _next){ next=_next; isWord=false; }};class Trie {public: Node* root; /** Initialize your data structure here. */ Trie() { root=new Node(); } /** Inserts a word into the trie. */ void insert(string word) { Node* temp=root; for(int i=0;i&lt;word.length();i++){ auto it=temp-&gt;next.find(word[i]); if(it==temp-&gt;next.end()){ temp-&gt;next[word[i]]=new Node(); temp=temp-&gt;next[word[i]]; }else temp=temp-&gt;next[word[i]]; } temp-&gt;isWord=true; } /** Returns if the word is in the trie. */ bool search(string word) { Node* temp=root; for(int i=0;i&lt;word.length();i++){ auto it=temp-&gt;next.count(word[i]); if(!it) return false; temp=temp-&gt;next[word[i]]; } if(temp-&gt;isWord) return true; return false; } /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) { Node* temp=root; for(int i=0;i&lt;prefix.length();i++){ if(temp-&gt;next.count(prefix[i])==0) return false; temp=temp-&gt;next[prefix[i]]; } return true; }}; 677. Map Sum Pairs 键值映射和上题类似，区别在于用递归思想求前缀总和。 考虑过在每个结点都写入当前值的方法，但是感觉这样每次插入新结点都需要去更新整个树，复杂度欠缺考虑。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Node{public: int num=0; unordered_map&lt;char,Node*&gt; next; Node() {} Node(unordered_map&lt;char,Node*&gt; _next){ next=_next; }};class MapSum {public: Node *root; /** Initialize your data structure here. */ MapSum() { root=new Node(); } void insert(string key, int val) { Node *temp=root; for(int i=0;i&lt;key.length();i++){ auto it=temp-&gt;next.find(key[i]); if(it==temp-&gt;next.end()){ temp-&gt;next[key[i]]=new Node(); temp=temp-&gt;next[key[i]]; } else temp=temp-&gt;next[key[i]]; } temp-&gt;num=val; } int sum(string prefix) { Node *temp=root; for(int i=0;i&lt;prefix.length();i++){ auto it=temp-&gt;next.find(prefix[i]); if(it==temp-&gt;next.end()) return 0; else temp=temp-&gt;next[prefix[i]]; } return help(temp); } int help(Node *p){ int sum=p-&gt;num; for(auto it=p-&gt;next.begin();it!=p-&gt;next.end();it++) sum+=help(it-&gt;second); return sum; }}; 648. Replace Words 单词替换写得有些自闭，不想说话。逻辑不难，主要是对于C++中string类的运用暂时还有所欠缺，特别对于一个长句子的处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798class Node {public: bool isWord=false; unordered_map&lt;char,Node*&gt; next; Node() { isWord=false; } Node(unordered_map&lt;char,Node*&gt; _next){ next=_next; isWord=false; }};class Trie {public: Node* root; /** Initialize your data structure here. */ Trie() { root=new Node(); } /** Inserts a word into the trie. */ void insert(string word) { Node* temp=root; for(int i=0;i&lt;word.length();i++){ auto it=temp-&gt;next.find(word[i]); if(it==temp-&gt;next.end()){ temp-&gt;next[word[i]]=new Node(); temp=temp-&gt;next[word[i]]; }else temp=temp-&gt;next[word[i]]; } temp-&gt;isWord=true; } /** Returns if the word is in the trie. */ bool search(string word) { Node* temp=root; for(int i=0;i&lt;word.length();i++){ auto it=temp-&gt;next.count(word[i]); if(!it) return false; temp=temp-&gt;next[word[i]]; } if(temp-&gt;isWord) return true; return false; } /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) { Node* temp=root; for(int i=0;i&lt;prefix.length();i++){ if(temp-&gt;next.count(prefix[i])==0) return false; temp=temp-&gt;next[prefix[i]]; } return true; }};class Solution {public: string replaceWords(vector&lt;string&gt;&amp; dict, string sentence) { Trie tire; vector&lt;string&gt; temp; for(string it:dict) tire.insert(it); int i=0; string t; for(int i=0;i&lt;sentence.length();i++){ if(sentence[i]!=' ') { t+=sentence[i]; } else{ temp.push_back(t); t.clear(); } } temp.push_back(t); for(int it=0;it&lt;temp.size();it++){ Node *p=tire.root; string repre; for(int i=0;i&lt;temp[it].length();i++){ if(p-&gt;isWord){ temp[it]=repre; break; } auto it1=p-&gt;next.find(temp[it][i]); if(it1!=p-&gt;next.end()){ p=p-&gt;next[temp[it][i]]; } else break; repre+=temp[it][i]; } repre.clear(); } string res=temp[0]; for(int i=1;i&lt;temp.size();i++) res+=' '+temp[i]; return res; }};","link":"/2019/04/26/190426/"},{"title":"4.29LeetCode","text":"说一下，今天开始代码尽量准备用java写了，感觉好不习惯。。 198. House Robber 打家劫舍比较简单的动态规划题目。dp[i]=max(dp[i-1],dp[i-2]+nums[i]) 123456789101112131415161718192021222324252627282930// dp[i]表示前n户并且抢劫过第n家的max，感觉自己想复杂了。。。也可以通过。// class Solution {// public:// int rob(vector&lt;int&gt;&amp; nums) {// if(nums.empty()) return 0;// if(nums.size()==1) return nums[0];// if(nums.size()==2) return max(nums[0],nums[1]);// vector&lt;int&gt; dp;// dp.resize(nums.size());// dp[0]=nums[0]; dp[1]=nums[1]; dp[2]=nums[0]+nums[2];// for(int i=3;i&lt;nums.size();i++)// dp[i]=max(dp[i-2]+nums[i],dp[i-3]+nums[i]);// return max(dp[nums.size()-1],dp[nums.size()-2]);// }// };class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { if(nums.empty()) return 0; if(nums.size()==1) return nums[0]; vector&lt;int&gt; dp; dp.resize(nums.size()); dp[0]=nums[0]; dp[1]=max(nums[0],nums[1]); for(int i=2;i&lt;nums.size();i++) dp[i]=max(dp[i-1],dp[i-2]+nums[i]); return dp[nums.size()-1]; }}; 384. Shuffle an Array 打乱数组第一次写java，感觉好难啊。。踩了好多坑，数组的深浅拷贝和伪随机函数等等.. 慢慢学吧 注释的是评论区大佬的答案。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Solution { int[] Arr; int[] Nature; public Solution(int[] nums) { Arr=nums; Nature= Arrays.copyOf(Arr, Arr.length); } /** Resets the array to its original configuration and return it. */ public int[] reset() { for(int i=0;i&lt;Arr.length;i++) Arr[i]=Nature[i]; return Arrays.copyOf(Arr, Arr.length); } /** Returns a random shuffling of the array. */ public int[] shuffle() { for(int i=Arr.length-1;i&gt;0;i--){ Random rand=new Random(); int t=rand.nextInt(i+1); //随机数生成范围要注意 int temp=Arr[t]; Arr[t]=Arr[i]; Arr[i]=temp; } return Arr; }}/** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(nums); * int[] param_1 = obj.reset(); * int[] param_2 = obj.shuffle(); */// class Solution {// int[] nums;// public Solution(int[] nums) {// this.nums = nums;// } // /** Resets the array to its original configuration and return it. */// public int[] reset() {// return nums;// } // /** Returns a random shuffling of the array. */// public int[] shuffle() {// int[] result = Arrays.copyOf(nums, nums.length);// Random rand=new Random();// for(int i = nums.length - 1; i &gt; 0; i--) {// int n = rand.nextInt(i + 1);// // swap n and i // int tmp = result[n];// result[n] = result[i];// result[i] = tmp;// }// return result;// }// } 412. Fizz Buzzjava: 12345678910111213class Solution { public List&lt;String&gt; fizzBuzz(int n) { List&lt;String&gt; res=new ArrayList&lt;String&gt;(); for(int i=1;i&lt;=n;i++){ if(i%3==0&amp;&amp;i%5==0) res.add(\"FizzBuzz\"); else if(i%3==0&amp;&amp;i%5!=0) res.add(\"Fizz\"); else if(i%5==0&amp;&amp;i%3!=0) res.add(\"Buzz\"); else res.add(Integer.toString(i)); } return res; }} 204. Count Primes计数质数一开始的想法就是判断从1-n的每个数是否为质数，时间复杂度O(n^2)最简单的方法当然通过不了，参考了某大佬的一篇博客进行剪枝附连接：判断一个数是不是质数(素数)，3种方式介绍 1234567891011121314151617181920212223242526class Solution { public int countPrimes(int n) { int res=0; for(int i=1;i&lt;n;i++) if(isPrime(i)) res++; return res; } public static boolean isPrime(int num) { if (num &lt;= 3) { return num &gt; 1; } // 不在6的倍数两侧的一定不是质数 if (num % 6 != 1 &amp;&amp; num % 6 != 5) { return false; } int sqrt = (int) Math.sqrt(num); for (int i = 5; i &lt;= sqrt; i += 6) { if (num % i == 0 || num % (i + 2) == 0) { return false; } } return true; }} 然后根据题目下面的提示，了解了埃拉托色尼筛选法（质数问题）。唯一疑惑就是明明应该可以从i*i开始覆盖，不知道为什么总会报错说数组越界。 123456789101112131415161718class Solution { public int countPrimes(int n) { if(n&lt;3) return 0; int res=0; int[] temp=new int[n]; for(int i=0;i&lt;n;i++) temp[i]=i; for(int i=2;i&lt;n;i++){ if(temp[i]==i){ res++; for(int j=2;j*i&lt;n;j++) temp[j*i]=i; } } return res; }} 326. Power of Three递归解法很常规 1234567class Solution { public boolean isPowerOfThree(int n) { if(n==1) return true; else if(n%3!=0||n==0) return false; else return isPowerOfThree(n/3); }} 评论区大佬的两种解法： 1234567class Solution { public boolean isPowerOfThree(int n) { String str=Integer.toString(n,3); //将n由十进制转化为3进制(java进制转换的写法，学到了) boolean result = str.matches(\"^10*$\");//^表示正则开始，$表示正则结束,意思为匹配1开头中间可以无数个0的字符 return result; }} 12345class Solution { public boolean isPowerOfThree(int n) { return n &gt; 0 &amp;&amp; 1162261467%n == 0; }} 13. Roman to Integer写得太丑陋了。。不忍直视。。。有空一定重新用switch写下。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Solution { public int romanToInt(String s) { int res=0; int i=0; while(i&lt;s.length()){ if(s.charAt(i)=='M') { res+=1000; i++; continue; } if(s.charAt(i)=='D'){ res+=500; i++; continue; } if(s.charAt(i)=='C'){ if(i+1&lt;s.length()&amp;&amp;s.charAt(i+1)=='D'){ res+=400; i+=2; } else if(i+1&lt;s.length()&amp;&amp;s.charAt(i+1)=='M'){ res+=900; i+=2; } else { res+=100; i++; } continue; } if(s.charAt(i)=='L'){ res+=50; i++; continue; } if(s.charAt(i)=='X'){ if(i+1&lt;s.length()&amp;&amp;s.charAt(i+1)=='L'){ res+=40; i+=2; } else if(i+1&lt;s.length()&amp;&amp;s.charAt(i+1)=='C'){ res+=90; i+=2; } else { res+=10; i++; } continue; } if(s.charAt(i)=='V'){ res+=5; i++; continue; } if(s.charAt(i)=='I'){ if(i+1&lt;s.length()&amp;&amp;s.charAt(i+1)=='V'){ res+=4; i+=2; } else if(i+1&lt;s.length()&amp;&amp;s.charAt(i+1)=='X'){ res+=9; i+=2; } else { res+=1; i++; } continue; } } return res; }} 191. Number of 1 Bits为什么java里面没有unsignedint啊？？？？？？学了了评论区大佬的解法，体会了下n=n&amp;(n-1)的妙用(每次可以消掉一个1). 1234567891011public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { int count = 0; while (n != 0) { count++; n = n &amp; (n - 1); } return count; }}","link":"/2019/04/29/190429/"},{"title":"5.3LeetCode","text":"前两天放假，就没更新，每天也做不了几题，今天集中更新下。 步入五月，感觉生活正在逐渐变得紧凑，这学期的课程都还没咋学，还有三门实验课要应付，再加上最近开始看java了，所以以后刷题量可能会减少点，但肯定不会停下！还有个问题就是，初级算法卡片刷完了，现在开始刷中级算法了，感觉好难啊！。。头秃。 15.3Sum 15.三数之和C++.感觉好难啊！一开始不知道为什么总想着用map做，试了半天总是无法解决漏解的问题。。看了答案才会做。第一个是三指针的处理方式，将复杂度从O(n^3)降到了O(n^2)。学习了。第二个是重复解的剔除，不需要通过set就可以实现。 12345678910111213141516171819202122232425class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { std::sort(nums.begin(),nums.end()); vector&lt;vector&lt;int&gt;&gt; res; int n=nums.size(); for(int k=n-1;k&gt;1;k--){ int i=0,j=k-1; while(i&lt;j){ if(nums[i]+nums[j]+nums[k]&gt;0) j--; else if(nums[i]+nums[j]+nums[k]&lt;0) i++; else{ vector&lt;int&gt; temp={nums[i],nums[j],nums[k]}; res.push_back(temp); while(i+1&lt;n&amp;&amp;nums[i+1]==nums[i]) i++; i++; while(j-1&gt;=0&amp;&amp;nums[j-1]==nums[j]) j--; j--; } } while(k-1&gt;=0&amp;&amp;nums[k-1]==nums[k]) k--; } return res; }}; 73. Set Matrix Zeroes 73.矩阵置零之前看过这道题，大概知道不用额外空间思路，但是自己写起来又犯蠢了。。用来做标志位的首行和首列不能先乱动(不然就全部变成0了)，，解决方案是用两个bool去存是否要把首行首列变0 1234567891011121314151617181920212223242526272829303132class Solution { public void setZeroes(int[][] matrix) { boolean row=false,coloum=false; for(int j=0;j&lt;matrix[0].length;j++) if(matrix[0][j]==0){ row=true; break; } for(int i=0;i&lt;matrix.length;i++) if(matrix[i][0]==0){ coloum=true; break; } for(int i=0;i&lt;matrix.length;i++) for(int j=0;j&lt;matrix[0].length;j++) if(matrix[i][j]==0){ matrix[i][0]=0; matrix[0][j]=0; } for(int i=1;i&lt;matrix.length;i++) for(int j=1;j&lt;matrix[0].length;j++) if(matrix[i][0]==0||matrix[0][j]==0) matrix[i][j]=0; if(row) for(int j=0;j&lt;matrix[0].length;j++) matrix[0][j]=0; if(coloum) for(int i=0;i&lt;matrix.length;i++) matrix[i][0]=0; }} 5. Longest Palindromic Substring 最长回文子串这道题简直是剧毒。。做得我头都大了。昨天晚上做了俩小时，今天下午又看了俩小时 做了三种方法，dp，中心拓展，马拉车算法 解法1： 动态规划二维动态规划，不看答案根本想不到。bobo 123456789101112131415161718192021222324252627282930313233class Solution { public String longestPalindrome(String s) { String res=new String(); int n=s.length(); boolean[][] dp=new boolean[n][n]; for(int i=0;i&lt;n;i++) dp[i][i]=true; for(int i=0;i&lt;n-1;i++){ if(s.charAt(i)==s.charAt(i+1)) dp[i][i+1]=true; else dp[i][i+1]=false; } for(int k=2;k&lt;n;k++){ for(int i=0;i&lt;n-k;i++){ if(dp[i+1][k+i-1]==true &amp;&amp; s.charAt(i)==s.charAt(k+i)) dp[i][k+i]=true; else dp[i][k+i]=false; } } int flag=0; for(int i=n-1;i&gt;=0;i--){ for(int j=0;j&lt;n-i;j++) if(dp[j][i+j]==true){ flag=1; res=s.substring(j,i+j+1); break; } if(flag==1) break; } return res; }} 解法2： 中心拓展算法比较容易理解，但是没想到当时。 1234567891011121314151617181920212223public String longestPalindrome(String s) { if (s == null || s.length() &lt; 1) return &quot;&quot;; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) { int len1 = expandAroundCenter(s, i, i); int len2 = expandAroundCenter(s, i, i + 1); int len = Math.max(len1, len2); if (len &gt; end - start) { start = i - (len - 1) / 2; end = i + len / 2; } } return s.substring(start, end + 1);}private int expandAroundCenter(String s, int left, int right) { int L = left, R = right; while (L &gt;= 0 &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) { L--; R++; } return R - L - 1;} 解法3： 马拉车算法网上博客都看不太懂，说得都不是人话。。找了篇漫画感觉讲的还挺形象的，附上链接：点击查看漫画 然后照着源码写了下java版本的，第一次用StringBuffer. sb哈哈哈。感慨On复杂度确实比On^2快了好多…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution { public String preHandle(String s){ StringBuffer sb=new StringBuffer(); sb.append(&apos;#&apos;); for(int i=0;i&lt;s.length();i++){ sb.append(s.charAt(i)); sb.append(&apos;#&apos;); } return sb.toString(); } public String longestPalindrome(String s) { String str=preHandle(s); int rightboard=0; int rightcenter=0; int[] halflen = new int[str.length()]; int center=0; int maxlen=0; for(int i=0;i&lt;str.length();i++){ boolean needSearch=true; if(i&lt;rightboard){ int left=2*rightcenter-i; halflen[i]=halflen[left]; if(i+halflen[i]&gt;rightboard) halflen[i]=rightboard-i; if(i+halflen[i]&lt;rightboard) needSearch=false; } if(needSearch){ while(i-halflen[i]-1&gt;=0 &amp;&amp;i+halflen[i]+1&lt;str.length()){ if(str.charAt(i-halflen[i]-1)==str.charAt(i+halflen[i]+1)){ halflen[i]++; } else break; } rightboard=i+halflen[i]; rightcenter=i; if(halflen[i]&gt;maxlen){ center=i; maxlen=halflen[i]; } } } StringBuffer sb=new StringBuffer(); for(int i = center - maxlen + 1; i &lt;= center + maxlen; i += 2) { sb.append(str.charAt(i)); } return sb.toString(); }} 334. Increasing Triplet Subsequence 递增的三元子序列挺有意思的一道题，想清楚就好了，只要记录当前最小值和某个子序列里第二大的数就可以了。 12345678910111213141516class Solution { public boolean increasingTriplet(int[] nums) { if(nums.length&lt;3) return false; int low=Integer.MAX_VALUE, mid=Integer.MAX_VALUE; int i=0; while(i&lt;nums.length){ if(nums[i]&lt;=low) low=nums[i]; else if(nums[i]&lt;mid) mid=nums[i]; else if(nums[i]&gt;mid) return true; i++; } return false; }} 103. Binary Tree Zigzag Level Order Traversal 二叉树的锯齿形层次遍历层次遍历的变种，没啥难度。 12345678910111213141516171819202122232425262728293031class Solution { public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; res= new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; left=new Stack&lt;&gt;(); Stack&lt;TreeNode&gt; right=new Stack&lt;&gt;(); if(root==null) return res; right.push(root); boolean flag=true; while(!left.isEmpty() ||!right.isEmpty()){ List&lt;Integer&gt; l=new ArrayList&lt;&gt;(); if(flag){ while(!right.isEmpty()){ TreeNode temp=right.pop(); l.add(temp.val); if(temp.left!=null) left.push(temp.left); if(temp.right!=null) left.push(temp.right); } } else while(!left.isEmpty()){ TreeNode temp=left.pop(); l.add(temp.val); if(temp.right!=null) right.push(temp.right); if(temp.left!=null) right.push(temp.left); } res.add(l); flag=!flag; } return res; }} 230. Kth Smallest Element in a BST 二叉搜索树中第K小的元素中序遍历即可。 123456789101112131415class Solution { public int kthSmallest(TreeNode root, int k) { List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); help(root,list,k); return (int)list.get(k-1); } public void help(TreeNode p,List&lt;Integer&gt; list,int k){ if(p==null||k==0) return; help(p.left,list,k); k--; list.add(p.val); help(p.right,list,k); }} 17. Letter Combinations of a Phone Number 电话号码的字母组合发现之前好久没接触过回溯的题目了。。第一个想法就是for循环，但是不知道String的长度偷看了评论区答案，用递归去写。。。没有必要记录步长、。 1234567891011121314151617181920212223class Solution { public List&lt;String&gt; letterCombinations(String digits) { int n=digits.length(); String s=new String(); List&lt;String&gt; res=new ArrayList&lt;&gt;(); if(n==0) return res; help(res,&quot;&quot;,digits); return res; } private void help(List&lt;String&gt; list,String s,String digits){ String[] reps={&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;}; if(s.length()==digits.length()){ list.add(s); return; } int n=s.length(); String rep=reps[digits.charAt(n)-50]; for(int i=0;i&lt;rep.length();i++) { help(list,s+rep.charAt(i),digits); } }} 22. Generate Parentheses 22.括号生成 1234567891011121314151617class Solution { public List&lt;String&gt; generateParenthesis(int n) { List&lt;String&gt; res=new ArrayList&lt;&gt;(); if(n==0) return res; help(res,0,0,n,&quot;&quot;); return res; } public void help(List&lt;String&gt; list, int left, int right,int n, String s){ if(left==right&amp;&amp;left==n) { list.add(s); return; } if(left&lt;n) help(list,left+1,right,n,s+&apos;(&apos;); if(right&lt;left) help(list,left,right+1,n,s+&apos;)&apos;); return; }} 终于贴完了，收工！","link":"/2019/05/03/190503/"},{"title":"洗牌算法","text":"三种洗牌算法shuffle在csdn上看了篇博客，感觉不错，在这儿贴过来 背景笔试时，遇到一个算法题：差不多是 在n个不同的数中随机取出不重复的m个数。洗牌算法是将原来的数组进行打散，使原数组的某个数在打散后的数组中的每个位置上等概率的出现，刚好可以解决该问题。 洗牌算法由抽牌、换牌和插牌衍生出三种洗牌算法，其中抽牌和换牌分别对应Fisher-Yates Shuffle和Knuth-Durstenfeld Shhuffle算法。 2.1 Fisher-Yates Shuffle算法 最早提出这个洗牌方法的是 Ronald A. Fisher 和 Frank Yates，即 Fisher–Yates Shuffle，其基本思想就是从原始数组中随机取一个之前没取过的数字到新的数组中，具体如下： 初始化原始数组和新数组，原始数组长度为n(已知)； 从还没处理的数组（假如还剩k个）中，随机产生一个[0, k)之间的数字p（假设数组从0开始）； 从剩下的k个数中把第p个数取出； 重复步骤2和3直到数字全部取完； 从步骤3取出的数字序列便是一个打乱了的数列。 下面证明其随机性，即每个元素被放置在新数组中的第i个位置是1/n（假设数组大小是n）。证明：一个元素m被放入第i个位置的概率P = 前i-1个位置选择元素时没有选中m的概率 * 第i个位置选中m的概率，即 12345678910111213#define N 10#define M 5void Fisher_Yates_Shuffle(vector&lt;int&gt;&amp; arr,vector&lt;int&gt;&amp; res){ srand((unsigned)time(NULL)); int k; for (int i=0;i&lt;M;++i) { k=rand()%arr.size(); res.push_back(arr[k]); arr.erase(arr.begin()+k); }} 时间复杂度为O(n*n),空间复杂度为O(n). 2.2 Knuth-Durstenfeld Shuffle Knuth 和 Durstenfeld 在Fisher 等人的基础上对算法进行了改进，在原始数组上对数字进行交互，省去了额外O(n)的空间。该算法的基本思想和 Fisher 类似，每次从未处理的数据中随机取出一个数字，然后把该数字放在数组的尾部，即数组尾部存放的是已经处理过的数字。 算法步骤为： 1. 建立一个数组大小为 n 的数组 arr，分别存放 1 到 n 的数值； 2. 生成一个从 0 到 n - 1 的随机数 x； 3. 输出 arr 下标为 x 的数值，即为第一个随机数； 4. 将 arr 的尾元素和下标为 x 的元素互换； 5. 同2，生成一个从 0 到 n - 2 的随机数 x； 6. 输出 arr 下标为 x 的数值，为第二个随机数； 7. 将 arr 的倒数第二个元素和下标为 x 的元素互换； …… 如上，直到输出 m 个数为止 该算法是经典洗牌算法。它的proof如下：对于arr[i],洗牌后在第n-1个位置的概率是1/n（第一次交换的随机数为i）在n-2个位置概率是[(n-1)/n] [1/(n-1)] = 1/n，（第一次交换的随机数不为i，第二次为arr[i]所在的位置（注意，若i=n-1，第一交换arr[n-1]会被换到一个随机的位置））在第n-k个位置的概率是[(n-1)/n] [(n-2)/(n-1)] … [(n-k+1)/(n-k+2)] *[1/(n-k+1)] = 1/n（第一个随机数不要为i，第二次不为arr[i]所在的位置(随着交换有可能会变)……第n-k次为arr[i]所在的位置）.12345678void Knuth_Durstenfeld_Shuffle(vector&lt;int&gt;&amp;arr){ for (int i=arr.size()-1;i&gt;=0;--i) { srand((unsigned)time(NULL)); swap(arr[rand()%(i+1)],arr[i]); }} 时间复杂度为O(n),空间复杂度为O(1),缺点必须知道数组长度n. 原始数组被修改了，这是一个原地打乱顺序的算法，算法时间复杂度也从Fisher算法的 O(n2)提升到了O(n)。由于是从后往前扫描，无法处理不知道长度或动态增长的数组。 2.3 Inside-Out Algorithm Knuth-Durstenfeld Shuffle 是一个内部打乱的算法，算法完成后原始数据被直接打乱，尽管这个方法可以节省空间，但在有些应用中可能需要保留原始数据，所以需要另外开辟一个数组来存储生成的新序列。 Inside-Out Algorithm 算法的基本思思是从前向后扫描数据，把位置i的数据随机插入到前i个（包括第i个）位置中（假设为k），这个操作是在新数组中进行，然后把原始数据中位置k的数字替换新数组位置i的数字。其实效果相当于新数组中位置k和位置i的数字进行交互。 如果知道arr的lengh的话，可以改为for循环，由于是从前往后遍历，所以可以应对arr[]数目未知的情况，或者arr[]是一个动态增加的情况。 证明如下：原数组的第 i 个元素（随机到的数）在新数组的前 i 个位置的概率都是：(1/i) [i/(i+1)] [(i+1)/(i+2)] … [(n-1)/n] = 1/n，（即第i次刚好随机放到了该位置，在后面的n-i 次选择中该数字不被选中）。原数组的第 i 个元素（随机到的数）在新数组的 i+1 （包括i + 1）以后的位置（假设是第k个位置）的概率是：(1/k) [k/(k+1)] [(k+1)/(k+2)] … [(n-1)/n] = 1/n（即第k次刚好随机放到了该位置，在后面的n-k次选择中该数字不被选中）。 12345678910111213void Inside_Out_Shuffle(const vector&lt;int&gt;&amp;arr,vector&lt;int&gt;&amp; res){ res.assign(arr.size(),0); copy(arr.begin(),arr.end(),res.begin()); int k; for (int i=0;i&lt;arr.size();++i) { srand((unsigned)time(NULL)); k=rand()%(i+1); res[i]=res[k]; res[k]=arr[i]; }} 时间复杂度为O(n),空间复杂度为O(n). 2.4 蓄水池抽样 从N个元素中随机等概率取出k个元素，N长度未知。它能够在o（n）时间内对n个数据进行等概率随机抽取。如果数据集合的量特别大或者还在增长（相当于未知数据集合总量），该算法依然可以等概率抽样. 伪代码： 123456Init : a reservoir with the size： k for i= k+1 to N M=random(1, i); if( M &lt; k) SWAP the Mth value and ith value end for 上述伪代码的意思是：先选中第1到k个元素，作为被选中的元素。然后依次对第k+1至第N个元素做如下操作：每个元素都有k/x的概率被选中，然后等概率的（1/k）替换掉被选中的元素。其中x是元素的序号。 proof：每次都是以 k/i 的概率来选择例: k=1000的话， 从1001开始作选择，1001被选中的概率是1000/1001，1002被选中的概率是1000/1002，与我们直觉是相符的。接下来证明：假设当前是i+1, 按照我们的规定，i+1这个元素被选中的概率是k/i+1，也即第 i+1 这个元素在蓄水池中出现的概率是k/i+1此时考虑前i个元素，如果前i个元素出现在蓄水池中的概率都是k/i+1的话，说明我们的算法是没有问题的。 对这个问题可以用归纳法来证明：k &lt; i &lt;=N1.当i=k+1的时候，蓄水池的容量为k，第k+1个元素被选择的概率明显为k/(k+1), 此时前k个元素出现在蓄水池的概率为 k/(k+1), 很明显结论成立。2.假设当 j=i 的时候结论成立，此时以 k/i 的概率来选择第i个元素，前i-1个元素出现在蓄水池的概率都为k/i。证明当j=i+1的情况：即需要证明当以 k/i+1 的概率来选择第i+1个元素的时候，此时任一前i个元素出现在蓄水池的概率都为k/(i+1).前i个元素出现在蓄水池的概率有2部分组成, ①在第i+1次选择前得出现在蓄水池中，②得保证第i+1次选择的时候不被替换掉①.由2知道在第i+1次选择前，任一前i个元素出现在蓄水池的概率都为k/i②.考虑被替换的概率：首先要被替换得第 i+1 个元素被选中(不然不用替换了)概率为 k/i+1，其次是因为随机替换的池子中k个元素中任意一个，所以不幸被替换的概率是 1/k，故前i个元素(池中元素)中任一被替换的概率 = k/(i+1) 1/k = 1/i+1则(池中元素中)没有被替换的概率为: 1 - 1/(i+1) = i/i+1综合① ②,通过乘法规则得到前i个元素出现在蓄水池的概率为 k/i i/(i+1) = k/i+1故证明成立如果m被选中，则随机替换水库中的一个对象。最终每个对象被选中的概率均为k/n，证明如下： 证明：第m个对象被选中的概率=选择m的概率（其后元素不被选择的概率+其后元素被选择的概率不替换第m个对象的概率），即 1234567891011void Reservoir_Sampling(vector&lt;int&gt;&amp; arr){ int k; for (int i=M;i&lt;arr.size();++i) { srand((unsigned)time(NULL)); k=rand()%(i+1); if (k&lt;M) swap(arr[k],arr[i]); }} 因此，蓄水池抽样因为不需知道n的长度，可用于机器学习的数据集的划分，等概率随机抽样分为测试集和训练集。 作者：lyz_cs来源：CSDN原文：https://blog.csdn.net/qq_26399665/article/details/79831490版权声明：本文为博主原创文章，转载请附上博文链接！","link":"/2019/04/29/洗牌算法/"}],"tags":[{"name":"二叉搜索树","slug":"二叉搜索树","link":"/tags/二叉搜索树/"},{"name":"N叉树","slug":"N叉树","link":"/tags/N叉树/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"数组","slug":"数组","link":"/tags/数组/"},{"name":"动态规划","slug":"动态规划","link":"/tags/动态规划/"},{"name":"链表","slug":"链表","link":"/tags/链表/"},{"name":"合并排序","slug":"合并排序","link":"/tags/合并排序/"},{"name":"双指针","slug":"双指针","link":"/tags/双指针/"},{"name":"贪心算法","slug":"贪心算法","link":"/tags/贪心算法/"},{"name":"字符串","slug":"字符串","link":"/tags/字符串/"},{"name":"位运算","slug":"位运算","link":"/tags/位运算/"},{"name":"回溯","slug":"回溯","link":"/tags/回溯/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"排序搜索","slug":"排序搜索","link":"/tags/排序搜索/"},{"name":"随便写写","slug":"随便写写","link":"/tags/随便写写/"},{"name":"ASR","slug":"ASR","link":"/tags/ASR/"},{"name":"SR/LID","slug":"SR-LID","link":"/tags/SR-LID/"},{"name":"n叉树","slug":"n叉树","link":"/tags/n叉树/"},{"name":"递归迭代","slug":"递归迭代","link":"/tags/递归迭代/"},{"name":"前缀树","slug":"前缀树","link":"/tags/前缀树/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"算法","slug":"算法","link":"/tags/算法/"}],"categories":[{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"杂谈","slug":"杂谈","link":"/categories/杂谈/"},{"name":"声纹识别","slug":"声纹识别","link":"/categories/声纹识别/"},{"name":"测试","slug":"测试","link":"/categories/测试/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"}]}
{"pages":[{"title":"tages","text":"","link":"/tages/index.html"},{"title":"test","text":"","link":"/test/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"4.25LeetCode","text":"总结： 昨天晚上被蚊子咬到睡不着觉，好不容易进入梦乡，恍惚间又听到噗通一声，我当时就料想到是手机掉到床柜后面去了，于是早上七点多钟又爬起来翻箱倒柜找手机关闹钟。所以意料当中地今天上午下午摸鱼只做了三条题目，都是比较ez的，晚上划水搭建了下博客。 701. Insert into a Binary Search TreeGiven the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them. For example, Given the tree: 4 / \\ 2 7 / \\ 1 3 And the value to insert: 5 You can return this binary search tree: 4 / \\ 2 7 / \\ / 1 3 5 This tree is also valid: 5 / \\ 2 7 / \\ 1 3 \\ 4 解答:方案1 递归解决123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* insertIntoBST(TreeNode* root, int val) { if(!root) return new TreeNode(val); if(val &gt; root-&gt;val){ if(root-&gt;right==nullptr) root-&gt;right=new TreeNode(val); else insertIntoBST(root-&gt;right,val); } else if(val &lt; root-&gt;val){ if(root-&gt;left==nullptr) root-&gt;left=new TreeNode(val); else insertIntoBST(root-&gt;left,val); } return root; }}; 方案2 迭代求解，用时明显短于递归1234567891011121314151617class Solution {public: TreeNode* insertIntoBST(TreeNode* root, int val) { if(!root) return new TreeNode(val); TreeNode *p=root; while(1){ if(val&lt;p-&gt;val&amp;&amp;p-&gt;left) p=p-&gt;left; else if(val&gt;p-&gt;val&amp;&amp;p-&gt;right) p=p-&gt;right; else break; } if(p-&gt;val &lt;val) p-&gt;right=new TreeNode(val); else p-&gt;left=new TreeNode(val); return root; }}; 原题中特地强调，可以改变树的结构，但是相对来说比较复杂，翻了翻评论区并没有这么写的解答，我思考了下，感觉与平衡二叉树的删除类似，在找到其应该插入位置后根据是否存在左右子树分类谈论。二叉树实在是太复杂啦！ 235. Lowest Common Ancestor of a Binary Search Tree 二叉搜索树的最近公共祖先Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5] Example 1: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8Output: 6Explanation: The LCA of nodes 2 and 8 is 6. Example 2: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4Output: 2Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes’ values will be unique.p and q are different and both values will exist in the BST. 解法： 递归实在是太好写啦，主要注意其二叉搜索树的特性。123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(!root) return nullptr; if(p-&gt;val&lt;root-&gt;val &amp;&amp; q-&gt;val&gt;root-&gt;val) return root; if(p-&gt;val&gt;root-&gt;val &amp;&amp; q-&gt;val&lt;root-&gt;val) return root; if(p==root||q==root) return root; if(p-&gt;val&lt;root-&gt;val &amp;&amp; q-&gt;val&lt;root-&gt;val) return lowestCommonAncestor(root-&gt;left,p,q); if(p-&gt;val&gt;root-&gt;val &amp;&amp; q-&gt;val&gt;root-&gt;val) return lowestCommonAncestor(root-&gt;right,p,q); return root; }}; 589. N-ary Tree Preorder Traversal N叉树的前序遍历 一开始写了个递归版本，发现速度很慢，想写迭代版本，但是感觉和二叉树又不太一样 参考了下评论区大神的思路 豁然开朗 随便写写写下来，发现时间还是特别高！ 非常生气地拿了80ms的源码来跑，结果虽然比我的好，还是很高。 就有点懵逼了。 感觉这个迭代写法还是可以学习一下，和之前常写的二叉树的前序遍历迭代版本不太相同。（对栈的使用）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/*// Definition for a Node.class Node {public: int val; vector&lt;Node*&gt; children; Node() {} Node(int _val, vector&lt;Node*&gt; _children) { val = _val; children = _children; }};*/// class Solution {// public:// vector&lt;int&gt; preorder(Node* root) {// vector&lt;int&gt; res;// help(root,res);// return res;// }// void help(Node* p,vector&lt;int&gt;&amp; res){// if(!p) return;// res.push_back(p-&gt;val);// for(auto it:p-&gt;children)// help(it,res);// }// };// class Solution {// public:// vector&lt;int&gt; preorder(Node* root) {// stack&lt;Node*&gt; stk;// vector&lt;int&gt; res;// if(!root) return res;// Node* p=root;// stk.push(p);// while(!stk.empty()){// p=stk.top();stk.pop();// res.push_back(p-&gt;val);// if(p-&gt;children.empty())// continue;// else{// for(auto it=p-&gt;children.rbegin();it!=p-&gt;children.rend();it++)// stk.push(*it);// }// }// return res; // }// };class Solution {public: vector&lt;int&gt; preorder(Node* root) { vector&lt;int&gt; res; if(root == nullptr) return res; stack&lt;Node*&gt; st; st.push(root); while(!st.empty()) { Node* t = st.top(); st.pop(); res.push_back(t-&gt;val); for(auto r = t-&gt;children.rbegin(); r != t-&gt;children.rend(); r++) { st.push(*r); } } return res; }};","link":"/2019/04/25/190425/"},{"title":"写在开博前的话","text":"博客作为一个逐渐被时代淘汰的产物，或许已经失去了其存在的必要。与我而言，这里可以是二十年前的树洞，十年前的日记本，五年前的笔记。 步入大三下学期以来，的确感受到了对未来的迷茫与无助。开这个博客的目的，主要还是希望自己能够坚持每日更新所学知识到其上，不定期可能更新一些自己的一些思考，理念，烦心事种种。 希望自己明年这个时候，再回头看这个博客时，有所收获！祝愿各位在抵达路途的末端，都不会后悔。","link":"/2019/04/25/paper/"},{"title":"Hello World","text":"这是个markdown语法示例，我懒得删了。以后还可以参考下。Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/04/23/hello-world/"}],"tags":[{"name":"二叉搜索树","slug":"二叉搜索树","link":"/tags/二叉搜索树/"},{"name":"N叉树","slug":"N叉树","link":"/tags/N叉树/"},{"name":"随便写写","slug":"随便写写","link":"/tags/随便写写/"}],"categories":[{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"杂谈","slug":"杂谈","link":"/categories/杂谈/"},{"name":"测试","slug":"测试","link":"/categories/测试/"}]}